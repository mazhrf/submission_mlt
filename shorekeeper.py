# -*- coding: utf-8 -*-
"""shorekeeper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18x-_wkzLhMK0ct5F9dTr27c1Eh5ygDB-

# **Recommendation System: Anime**
- **Nama:** Muhammad Azhar Fikri
- **Email:** muhammadazharfikri990@gmail.com
- **ID Dicoding:** ririee

![yn](https://i.pinimg.com/originals/31/63/4d/31634d375e820ae99a57147445387833.gif)

# **1. Import Library**

Pada tahap ini, mengimpor beberapa pustaka (library) Python yang dibutuhkan untuk analisis data dan pembangunan model machine learning.
"""

import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import seaborn as sns

from sklearn.neighbors import NearestNeighbors
from sklearn.metrics import davies_bouldin_score, calinski_harabasz_score
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer

from collections import Counter

import re
import html
import random
import warnings
warnings.filterwarnings('ignore')

import zipfile
from google.colab import files

"""# **2. Data Loading**

Memuat dataset dari Kaggle yakni Dataset `anime-recommendations-database` yang diupload oleh **CooperUnion**.
"""

files.upload()

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d CooperUnion/anime-recommendations-database

"""Selanjutnya, mengekstrak file zip."""

zip_ref = zipfile.ZipFile('/content/anime-recommendations-database.zip', 'r')
zip_ref.extractall('/content/')
zip_ref.close()

"""Dataset format `.csv` disimpan pada variabel dataframe `anime` dan `rating`"""

anime = pd.read_csv('anime.csv')
rating = pd.read_csv('rating.csv')

"""# **3. Data Understanding**

Data yang digunakan berasal dari dua file `.csv` yaitu `anime.csv` dan `rating.csv`

## **Dataset Anime**
Dataset ini berisi informasi tentang berbagai anime. Terdapat **12.294 entri** dalam dataset ini, dengan kolom-kolom sebagai berikut:
- **anime_id**: ID unik untuk setiap anime.
- **name**: Nama anime.
- **genre**: Genre atau kategori anime.
- **type**: Jenis anime.
- **episodes**: Jumlah episode yang tersedia untuk anime tersebut.
- **rating**: Rating rata-rata dari anime.
- **members**: Jumlah anggota yang menilai atau terdaftar pada anime tersebut.
"""

anime.head()

anime.info()

for i, (column_name, all_item) in enumerate(anime.count().items(), 1):
    print(f"kolom {i:2d}: {column_name} - total:  {all_item}")

print(f'{anime.shape[0]} baris dan {anime.shape[1]} kolom.')

"""Dataset ini memiliki beberapa nilai yang kosong pada kolom **genre** (62 nilai kosong), **type** (25 nilai kosong), dan **rating** (230 nilai kosong).

"""

anime.isnull().sum()

anime.duplicated().sum()

"""**Fitur Kategorikal (Categorical Features)**  
Fitur kategorikal biasanya berisi nilai-nilai yang dikelompokkan dalam kategori tertentu. Dari dataset yang tersedia, fitur yang tergolong kategorikal adalah:
- **name** (`object`) – Nama anime.
- **genre** (`object`) – Genre atau kategori anime.
- **type** (`object`) – Jenis anime (misalnya, TV, Movie, OVA, dll).
- **episodes** (`object`) – Jumlah episode

**Fitur Numerik (Numerical Features)**  
Fitur numerik mengandung nilai yang berupa angka. Fitur-fitur numerik dalam dataset ini adalah:
- **anime_id** (`int64`) – ID unik untuk setiap anime.
- **rating** (`float64`) – Rating rata-rata dari anime.
- **members** (`int64`) – Jumlah anggota yang menilai atau terdaftar pada anime tersebut.

**Kesimpulan**  
Dari analisis tipe data, dapat disimpulkan bahwa:
- Terdapat **4** fitur kategorikal yang berbentuk string (`object`), yaitu `name`, `genre`, `type`, dan `episodes`.
- Terdapat **3** fitur numerik, yaitu `anime_id`, `rating`, dan `members`. Fitur numerik ini terdiri dari dua tipe data: `integer` (`anime_id`, `members`) dan `float` (`rating`).

## **Dataset Rating (`rating.csv`)**
Dataset ini berisi informasi tentang rating yang diberikan oleh pengguna. Terdapat **7.813.737 entri** dalam dataset ini, dengan kolom-kolom sebagai berikut:
- **user_id**: ID unik untuk setiap pengguna yang memberikan rating.
- **anime_id**: ID anime yang diberi rating oleh pengguna.
- **rating**: Nilai rating yang diberikan oleh pengguna pada anime tersebut.
"""

rating.head()

rating.info()

for i, (column_name, all_item) in enumerate(rating.count().items(), 1):
    print(f"kolom {i:2d}: {column_name} - total:  {all_item}")

print(f'{rating.shape[0]} baris dan {rating.shape[1]} kolom.')

rating.isnull().sum()

"""Dataset ini memiliki 1 nilai duplikat"""

rating.duplicated().sum()

"""**Fitur Numerik (Numerical Features)**  
Fitur numerik mengandung nilai yang berupa angka. Fitur-fitur numerik dalam dataset ini adalah:
- **user_id** (`int64`) – ID unik untuk setiap pengguna yang memberikan rating.
- **anime_id** (`int64`) – ID anime yang diberi rating oleh pengguna.
- **rating** (`int64`) – Nilai rating yang diberikan oleh pengguna pada anime tersebut.

**Kesimpulan**   
Dari dataset `rating.csv`, terdapat **3** fitur numerik yang semuanya bertipe `int64`, yaitu `user_id`, `anime_id`, dan `rating`.

# **4. Exploratory Data Analysis (EDA)**

**Exploratory Data Analysis (EDA)** adalah pendekatan untuk menganalisis dan memahami data sebelum melakukan model prediksi. Tujuan utamanya adalah untuk mendapatkan wawasan awal dari data, seperti pola yang muncul, hubungan antar variabel, serta mendeteksi masalah kualitas data seperti nilai hilang atau outlier.

Menangani **missing value / null** pada `anime.csv`
"""

anime = anime.dropna()

print(f'{anime.shape[0]} baris dan {anime.shape[1]} kolom.')

anime.info()

"""Menangani **duplicate** pada `rating.csv`"""

rating = rating.drop_duplicates()

print(f'{rating.shape[0]} baris dan {rating.shape[1]} kolom.')

rating.info()

"""## **Visualisasi Dataset**"""

sns.set(style='whitegrid')
plt.rcParams['figure.figsize'] = (10, 6)

type_counts = anime['type'].value_counts()

labels = type_counts.index.tolist()
sizes = type_counts.values.tolist()

colors = ['#81F4E1', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B', '#A3A1FF']

plt.figure(figsize=(10,7))
plt.title('Layanan Penayangan Anime')
plt.pie(sizes, labels=labels, colors=colors[:len(labels)],
        autopct='%.2f %%', startangle=140)
plt.axis('equal')
plt.show()

genre_series = anime['genre'].dropna().str.split(', ')
genre_list = [genre for sublist in genre_series for genre in sublist]
genre_counts = Counter(genre_list)

top_genres = dict(genre_counts.most_common(10))
top_genres_sorted = dict(sorted(top_genres.items(), key=lambda item: item[1]))

labels = list(top_genres_sorted.keys())
sizes = list(top_genres_sorted.values())

colors = ['#81F4E1', '#56CBF9', '#F5D491', '#BEB7A4', '#B4E1FF', '#F06C9B', '#A3A1FF', '#FFD6A5', '#B5F7CC', '#FFABAB']

plt.figure(figsize=(10,7))
plt.title('Genre Anime Terpopuler')
plt.pie(sizes, labels=labels, colors=colors[:len(labels)],
        autopct='%.2f %%', startangle=140)
plt.axis('equal')
plt.show()

top_community = anime.sort_values(by='members', ascending=False).head(10)
top_community_reversed = top_community[::-1]
unique_colors_community = sns.color_palette("tab10", n_colors=len(top_community_reversed))

plt.figure(figsize=(10,6))
sns.barplot(
    x=top_community_reversed['members'],
    y=top_community_reversed['name'],
    palette=unique_colors_community
)

plt.gca().xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: '{:,.0f}'.format(x)))
plt.title('Top 10 Anime dengan Fandom Terbesar')
plt.xlabel('')
plt.ylabel('')
plt.show()

for index, row in top_community_reversed.iterrows():
    print(f"Anime: {row['name']}, Members: {row['members']:,}")

top_rated = anime.sort_values(by='rating', ascending=False).head(10)
top_rated_reversed = top_rated[::-1]
unique_colors_rated = sns.color_palette("tab10", n_colors=len(top_rated_reversed))

plt.figure(figsize=(10,6))
sns.barplot(
    x=top_rated_reversed['rating'],
    y=top_rated_reversed['name'],
    palette=unique_colors_rated
)

plt.gca().xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: '{:,.1f}'.format(x)))
plt.title('Top 10 Anime dengan Rating Tertinggi')
plt.xlabel('')
plt.ylabel('')
plt.show()

for index, row in top_rated_reversed.iterrows():
    print(f"Anime: {row['name']}, Rating: {row['rating']}")

"""# **4. Data Preparation**

Membersihkan simbol menggunakan **regex** pada data (`name`)
"""

def cleaning(txt):
    txt = html.unescape(txt)
    txt = re.sub(r"[^\w\s]", "", txt)
    return txt.strip()

anime['name'] = anime['name'].apply(cleaning)

anime

"""# **5. Model Development**"""

devnime = anime[['name', 'genre', 'type', 'episodes']].copy()

devnime

"""## **Content Based Filtering**

**TF-IDF** (Term Frequency-Inverse Document Frequency)
"""

vct = TfidfVectorizer(stop_words='english')
vct.fit(devnime['genre'])

vct.get_feature_names_out()

vct_matrix = vct.fit_transform(devnime['genre'])

vct_matrix.shape

vct_matrix.todense()

pd.DataFrame(
    vct_matrix.todense(),
    columns=vct.get_feature_names_out(),
    index=devnime.genre
).sample(22, axis=1).sample(10, axis=0)

"""**Cosine Similarity**"""

cs = cosine_similarity(vct_matrix)
cs

cs_df = pd.DataFrame(cs, index=devnime['name'], columns=devnime['name'])
print('Shape:', cs_df.shape)

cs_df.sample(5, axis=1).sample(5, axis=0)

subset = cs_df.sample(3, axis=1).sample(3, axis=0)

plt.figure(figsize=(12, 8))
sns.heatmap(subset, annot=False, cmap="coolwarm", linewidths=0.5)
plt.title("Rekomendasi Anime")
plt.xticks(rotation=90)
plt.yticks(rotation=0)
plt.tight_layout()
plt.xlabel(' ')
plt.ylabel(' ')
plt.show()

def recommend_anime(title, similarity_data=cs_df, items=devnime[['name', 'genre']], k=5):
    if title not in similarity_data.columns:
        return f"Anime '{title}' tidak ditemukan dalam data."

    idx = similarity_data[title].to_numpy().argpartition(range(-1, -k-1, -1))
    similar_animes = similarity_data.columns[idx[-1:-(k+2):-1]]
    similar_animes = similar_animes.drop(title, errors='ignore')

    return pd.DataFrame(similar_animes, columns=['name']).merge(items, on='name').head(k)

devnime[devnime.name.eq('Naruto')]

recommend_anime('Naruto')

recommend_anime('Bungou Stray Dogs')

"""## **Collaborative Filtering**

**K-Nearest Neighbor** (KNN) Method
"""

aniname = pd.DataFrame({'Nama Anime': anime['name']})

print(aniname.head())

anime.set_index('name', inplace=True)

anime_ngb = anime[['rating','type']]

anew = pd.get_dummies(anime_ngb[['type']])
anew = pd.concat([anime_ngb, anew], axis=1)
anew = anew.drop(columns='type')

anew.head()

knn = NearestNeighbors(metric='euclidean')
knn.fit(anew)

def recommend_nimek(anime_name: str, recommend_anime: int = 10):
    if anime_name not in anew.index:
        return f"Anime '{anime_name}' tidak ditemukan dalam data."

    print(f'Berdasarkan preferensimu terhadap anime: {anime_name}\nBerikut beberapa rekomendasi yang serupa:')

    distances, neighbors = knn.kneighbors(anew.loc[[anime_name]], n_neighbors=recommend_anime)
    similar_anime = anew.iloc[neighbors[0]].index.tolist()
    similar_distance = [f"{round(100 - distance, 2)}%" for distance in distances[0]]

    return pd.DataFrame({
        "Anime Name": similar_anime,
        "Similarity Score": similar_distance
    })

recommend_nimek('Shigatsu wa Kimi no Uso')

recommend_nimek('Kimi no Na wa')

"""# **6. Evaluasi**

**Davies-Bouldin** mengukur seberapa baik cluster dalam dataset, dan semakin rendah skor tersebut, semakin baik kualitas clustering yang dihasilkan. Skor yang lebih rendah menunjukkan bahwa cluster lebih terpisah dan lebih rapat satu sama lain.
"""

dbs = davies_bouldin_score(anew, aniname)
print(f"Davies-Bouldin: {dbs}")

"""**Calinski-Harabasz** juga dikenal sebagai Variance Ratio Criterion, adalah salah satu metrik evaluasi untuk mengukur kualitas hasil clustering."""

ch = calinski_harabasz_score(anew, aniname)
print("Calinski-Harabasz: ", ch)